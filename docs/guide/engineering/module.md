# 模块化详解

## 发展史

### 第一阶段

`JavaScript` 语言最初的设计目标，是作为浏览器的脚本语言，仅仅用于实现一些页面效果。

那个时候，一个页面所用到的`JS`可能只有区区几百行

在这种情况下，语言本身所存在的一些缺陷往往容易被大家忽略，因为程序规模太小。所以在这个阶段，也不存在什么专业的前端工程师

第一个阶段发生的大事件

- 1996 年，NetScape 将 JavaScript 语言提交给欧洲的一个标准制定阻止 ECMA（欧洲计算机制造商协会）
- 1998 年，NetScape 在与微软浏览器 IE 的竞争中失利，宣布破产

### 第二阶段

`AJAX`的出现，逐渐改变了浏览器脚本语言的使用场景，使得`JavaScript`不仅可以实现页面上的一些交互，还可以和服务器进行数据交互。

这个时候，一个页面所需要使用的`JS`代码行数越来越多，越来越复杂。

后端开发者的压力逐渐增加，使得一些公司开始招聘专业的前端开发者。

但此时，前端开发者的待遇远不如后端开发者，因为前端开发者承担的开发任务相对于后端还是比较简单的，同时也因为以下原因，制约了前端的发展:

1. **浏览器解释执行 JS 的速度太慢**
2. **用户端的电脑配置不足**
3. 更多的代码带来了全局变量污染、依赖关系混乱等问题

在这个阶段，前端开发处在一个非常尴尬的境地，它在传统的开发模式和前后端分离之间无助的徘徊

第二阶段的大事件：

1. IE 浏览器制霸市场后，几乎不再更新
2. ES4.0 流产，导致 JS 语言 10 年间几乎毫无变化
3. 2008 年 ES5 发布，仅解决了一些 JS API 不足的糟糕局面

### 第三阶段

到了 2008 年，谷歌的`V8`引擎发布，将`JavaScript`的执行速度推上了一个新的台阶。

突然间，制约前端发展的两大问题得以解决，此时，只剩下最后一个问题还在负隅顽抗，即**全局变量污染和依赖混乱**的问题，解决了它，前端便可以突破一切障碍，未来无可限量。

于是，全世界的前端开发者开始在社区中激烈的讨论，如何解决全局变量污染和依赖混乱的问题。

2008 年，有一个叫 Ryan Dahl 的小伙子，正在为一件事焦头烂额，他需要在服务器端手写一个高性能的 web 服务，经过分析，他确定，如果要实现高性能，那么必须要尽可能的减少线程，而要减少线程，避免不了要实用异步的处理方案。

一开始，他打算自己实用 C/C++语言来编写，可是这一过程实在太痛苦。

恰逢此时，谷歌 V8 引擎发布，Ryan 经过一些考量（单线程，异步，谷歌优化） 决定利用 V8 来编写高性能的服务器端程序。

于是，他基于开源的 V8 引擎，对源代码作了一些修改，便快速的完成了该项目。

2009 年，Ryan 推出了该 web 服务项目，命名为 nodejs。

从此，JS 第一次堂堂正正的入主后端，不再是必须附属于浏览器的“玩具”语言了。

也是从此刻开始，人们认识到，JS（ES）是一门真正的语言，它依附于运行环境（运行时）（宿主程序）而执行

<p style="text-align: center">
  <img src="/images/engineering/engineering-1.png" />
</p>

nodejs 的诞生，便把 JS 中的最后一个问题放到了台前，即**全局变量污染和依赖混乱**问题

最后经过社区的激烈讨论，最后形成一个模块化方案，这就是`CommonJS`,该方案彻底的解决了全局变量污染和依赖混乱的问题。

此方案一出，也立刻被`nodejs`所支持，于是，nodejs 成为了第一个为 JS 语言实现模块化的平台，为前端接下来的迅猛发展奠定了实践基础

该阶段发生的大事件：

- 2008 年，V8 发布
- IE 的市场逐步被 firefox 和 chrome 蚕食，现已无力回天
- 2009 年，nodejs 发布，并附带 commonjs 模块化标准

### 第四阶段

CommonJS 的出现打开了前端开发者的思路

既然后端可以使用模块化的 JS，作为 JS 语言的老东家浏览器为什么不行呢？

但是此时运行到浏览器其实是困难得（同步执行）

所以就有人想，如果 CommonJS 无法在浏览器上使用，那我们能不能自己定义一个标准出来，在浏览器上运行呢？

于是很快，AMD 规范出炉，它解决的问题和 CommonJS 一样，但是可以更好的适应浏览器环境

相继的，CMD 规范出炉，它对 AMD 规范进行了改进

这些行为，都受到了 ECMA 官方的密切关注......

于是，ECMA 官方开始考虑 JS 的模块化问题，最终在 2015 年，提出了 ES6 的模块化方案

从此，模块化成为了 JS 本身特有的属性

于此同时，很多开发者、技术厂商早已预见到 JS 的无穷潜力，于是有了下面的故事

- 既然 JS 也能编写大型应用，那么自然也需要像其他语言那样有解决复杂问题的开发框架
  - Angular、React、Vue 等前端开发框架出现
  - Express、Koa 等后端开发框架出现
  - 各种后端数据库驱动出现
- 要开发大型应用，自然少不了各种实用的第三方库的支持
  - npm 包管理器出现，实用第三方库变得极其方便
  - webpack 等构建工具出现，专门用于打包和部署
- 既然 JS 可以放到服务器环境，为什么不能放到其他终端环境呢？
  - Electron 发布，可以使用 JS 语言开发桌面应用程序
  - RN 和 Vuex 等技术发布，可以使用 JS 语言编写移动端应用程序
  - 各种小程序出现，可以使用 JS 编写依附于其他应用的小程序
  - 目前还有很多厂商致力于将 JS 应用到各种其他的终端设备，最终形成大前端生态

> 可以看到，模块化的出现，是 JS 通向大型应用的基石，学习好模块化，变具备了编写大型应用的基本功。

## CommonJS

在 nodejs 中，由于有且仅有一个入口文件（启动文件），而开发一个大型应用，必然需要很多个模块，因此，nodejs 对模块化的需求比浏览器要大很多。

<p style="text-align: center">
  <img src="/images/engineering/engineering-2.png" />
</p>

由于 nodejs 刚刚发布之时，前端没有统一的，官方的模块化，所以就采用了 commonJs 作为其模块化规范

首先为大家介绍一下两个重要概念：**模块导入和模块导出**

### 模块导出

首先介绍下什么是模块？

模块就是一个 JS 问文件，它包含了一部分功能，并隐藏了自身的实现

所以模块有两个核心：**隐藏和暴露**

隐藏：隐藏内部实现逻辑

暴露：抛出对应方法，供外部使用

暴露即导出

<p style="text-align: center">
  <img src="/images/engineering/engineering-3.png" />
</p>

### 模块导入

当需要使用一个模块时，使用的是该模块暴露的部分（导出的部分），隐藏的部分是永远无法使用的。

**当通过某种语法或 api 去使用一个模块时，这个过程叫做模块的导入**

### CommomJS 规范

CommomJs 使用`require()导入`和`exports导出`来定义模块

具体规范如下：

1. 如果一个 JS 文件中存在`exports`或`require`，该 JS 文件是一个模块
2. 模块内的所有代码均为隐藏代码，包括全局变量、全局函数，这些全局的内容均不应该对全局变量造成任何污染
3. 如果一个模块需要暴露一些 API 提供给外部使用，需要通过`exports`导出，`exports`是一个空的对象，你可以为该对象添加任何需要导出的内容
4. 如果一个模块需要导入其他模块，通过`require`实现，`require`是一个函数，传入模块的路径即可返回该模块导出的整个内容

```javascript
// utils.js
var a = 1;
var b = 2;

exports.c = 123;

// 当你重新改变 module.exports 的指向时，也就意味着 exports !== module.exports，所以在exports.添加的属性，不会在导出的内容里
module.exports = {
  a,
  b,
};

// index.js
var utils = require('./utils'); // {a: 1, b: 2}

if (true) {
  // 可以写在条件里，同步执行，存在缓存，也存在阻塞问题
  var utils1 = require('./utils'); // {a: 1, b: 2}
}
```

### nodejs 对 CommonJS 的实现

为了实现 CommonJS 规范，nodejs 对模块做出了以下处理

1. 为了保证高效的执行，仅加载必要的模块。nodejs 只有执行到`require`函数时才会加载并执行模块

2. 为了隐藏模块中的代码，nodejs 执行模块时，会将模块中的所有代码放置到一个函数中执行，以保证不污染全局变量。

   ```js
   (function () {
     //模块中的代码
   })();
   ```

3. 为了保证顺利的导出模块内容，nodejs 做了以下处理

   1. 在模块开始执行前，初始化一个值`module.exports = {}`
   2. `module.exports`即模块的导出值
   3. 为了方便开发者便捷的导出，nodejs 在初始化完`module.exports`后，又声明了一个变量`exports = module.exports`

   ```js
   (function (module) {
     module.exports = {};
     var exports = module.exports;
     //模块中的代码
     return module.exports;
   })();
   ```

4. 为了避免反复加载同一个模块，nodejs 默认开启了模块缓存，如果加载的模块已经被加载过了，则会自动使用之前的导出结果

### 实现伪代码

```javascript
const cacheModule = {};

function myRequire(filePath) {
  const realPath = path.resolve(__dirname, filePath);
  const fileContent = fs.readFileSync(realPath, 'utf-8');

  // 实现模块缓存
  if (cacheModule[realPath]) {
    return cacheModule[realPath];
  }
  const module = {
    exports: {},
  };
  return (function (module) {
    var exports = module.exports;
    if (fileContent) {
      eval(fileContent);
    }

    cacheModule[realPath] = module.exports;

    return module.exports;
  })(module);
}
```

## CommonJs 为啥不能在浏览器中使用

首先介绍下，为什么 commonjs 规范不适用浏览器环境？

因为使用 `require` 导入模块是时，node 会做一下两件事情

1. 通过模块路径找到本机文件，并读取文件内容
2. 将文件中的代码放入到一个函数环境中执行，并将执行后 module.exports 的值作为 require 函数的返回结果

可以认为，nodejs 执行模块时，是同步执行的。

**当浏览器遇到 CommonJs**

当想把 commomjs 模块放到到浏览器端时，就遇到了一些问题

1. 浏览器需要加载的 JS 文件，都是远程从服务器读取的，而且网络运输的效率是远远低于本地读取的，所以就会导致，在浏览器端执行模块时，会出现很长时间的阻塞
2. 而且此规范也需要浏览器厂商的支持，但是厂商不认，因为这不是官方的规范

以上的两个问题，导致 commonjs 规范不适合浏览器环境

但是，也并不是说浏览器中不能实现模块化，只需解决上面的问题即可，比如：

1. 远程同步加载 JS 费时，那我们就改成回调的方式
2. 需要放到函数环境执行，那就在编写模块的时候直接包一个函数

基于这种简单有效的思路，就出现了 AMD 和 CMD 规范

## AMD & CMD

### AMD

全称是 Asynchronous Module Definition，即异步模块加载机制

require.js 实现了 AMD 规范

在 AMD 中，导入和导出模块的代码，都必须放置在 define 函数中

```javascript
define([依赖的模块列表], function (模块名称列表) {
  //模块内部的代码
  return 导出的内容;
});
```

### CMD

全称是 Common Module Definition，公共模块定义规范

sea.js 实现了 CMD 规范

在 CMD 中，导入和导出模块的代码，都必须放置在 define 函数中

```javascript
define(function (require, exports, module) {
  //模块内部的代码
});
```

## ES6 模块化

### 特点

ES6 模块化具有以下的特点

1. 使用依赖**预声明**的方式导入模块
   1. 依赖延迟声明
      1. 优点：某些时候可以提高效率
      2. 缺点：无法在一开始确定模块依赖关系（比较模糊）
   2. 依赖预声明
      1. 优点：在一开始可以确定模块依赖关系
      2. 缺点：某些时候效率较低
2. 灵活的多种导入导出方式
3. 规范的路径表示法：所有路径必须以./或../开头

### 基本导入导出

一. **模块的引入**

目前，浏览器使用以下方式引入一个 ES6 模块文件

```javascript

<script src="入口文件" type="module">

```

二. **模块的基本导出和导入**

ES6 中的模块导入导出分为两种：

1. 基本导入导出
2. 默认导入导出

基本导出

````javascript
/**
  类似于 ``` exports.xxx = xxxx ```

  基本导出可以有多个，每个必须有名称

  基本导出的语法如下：
 */

export 声明表达式

/** 或 */

export {具名符号}

/** 由于基本导出必须具有名称，所以要求导出内容必须跟上**声明表达式**或**具名符号** */

````

基本导入

````javascript
/**
  由于使用的是**依赖预加载**，因此，导入任何其他模块，导入代码必须放置到所有代码之前

  对于基本导出，如果要进行导入，使用下面的代码
 */

import { 导入的符号列表 } from '模块路径';

/**
  注意以下细节：

  - 导入时，可以通过关键字```as```对导入的符号进行重命名
  - 导入时使用的符号是常量，不可修改
  - 可以使用*号导入所有的基本导出，形成一个对象
 */
````

### 默认导入导出

一. **默认导出**

每个模块，除了允许有多个基本导出之外，还允许有一个默认导出

默认导出类似于 CommonJS 中的`module.exports`，由于只有一个，因此无需具名

具体的语法是

```javascript
export default 默认导出的数据;
```

或

```javascript
export { 默认导出的数据 as default };
```

由于每个模块仅允许有一个默认导出，因此，每个模块不能出现多个默认导出语句

二. **默认导入**

需要想要导入一个模块的默认导出，需要使用下面的语法

```js
import 接收变量名 from '模块路径';
```

类似于 CommonJS 中的

```js
var 接收变量名 = require('模块路径');
```

由于默认导入时变量名是自行定义的，因此没有别名一说

如果希望同时导入某个模块的默认导出和基本导出，可以使用下面的语法

```js
import 接收默认导出的变量, { 接收基本导出的变量 } from '模块路径';
```

注：如果使用\*号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性 default 存在

### 其他细节

1. 尽量导出不可变值

当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此）

因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生

2. **可以使用无绑定的导入用于执行一些初始化代码**

如果我们只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入：

```javascript
import '模块路径';
```

3. **可以使用绑定再导出，来重新导出来自另一个模块的内容**

有的时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成

```javascript
export { 绑定的标识符 } from '模块路径';
```
